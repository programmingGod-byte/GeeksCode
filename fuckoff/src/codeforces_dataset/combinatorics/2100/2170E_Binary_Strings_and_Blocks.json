{
    "contestId": 2170,
    "index": "E",
    "title": "E. Binary Strings and Blocks",
    "statement": "Define a\nblock\nin a binary string (a string consisting of characters\n0\nand/or\n1\n) as its continuous substring of characters of the same type that cannot be extended either to the left or to the right. For example, in the string\n110001111\n, there are three blocks:\n11\n(from the $$$1$$$-st character to the $$$2$$$-nd character);\n000\n(from the $$$3$$$-rd character to the $$$5$$$-th character);\n1111\n(from the $$$6$$$-th character to the $$$9$$$-th character).\nThe substring from the $$$7$$$-th character to the $$$9$$$-th character\n111\nis not a block because it can be extended to the left. The substring from the $$$1$$$-st character to the $$$5$$$-th character\n11000\nis not a block because it contains characters of different types.\nWe call a string\nbeautiful\nif we can remove\nexactly one block\nfrom it so that the resulting string consists of an\nodd\nnumber of blocks. For example:\nthe string\n110001111\nis beautiful because we can remove the block from the $$$3$$$-rd to the $$$5$$$-th character, resulting in the string\n111111\n, which consists of one block;\nthe string\n1010\nis beautiful because we can remove the block from the $$$1$$$-st to the $$$1$$$-st character, resulting in the string\n010\n, which consists of three blocks;\nthe string\n0000\nis not beautiful because the only way to remove a block from it will result in an empty string, which consists of $$$0$$$ blocks.\nYou are given an integer $$$n$$$ and $$$m$$$ constraints, the $$$i$$$-th of which is described by a pair of integers $$$l_i, r_i$$$. We denote the substring of the string $$$s$$$ from character $$$l$$$ to character $$$r$$$ inclusive as $$$s[l:r]$$$, that is, $$$s[l:r] = s_l s_{l+1} \\dots s_r$$$. Your task is to count the number of binary strings $$$s$$$ of length $$$n$$$ meeting the following condition:\nfor each $$$i$$$ from $$$1$$$ to $$$m$$$, the string $$$s[l_i:r_i]$$$ is beautiful.",
    "inputSpecification": "Input\nThe first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test case.\nThe first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 3 \\cdot 10^5$$$; $$$1 \\le m \\le 3 \\cdot 10^5$$$) — the required length of the string and the number of constraints, respectively.\nNext, there are $$$m$$$ lines, the $$$i$$$-th of which contains two integers $$$l_i, r_i$$$ ($$$1 \\le l_i  \\lt  r_i \\le n$$$) — the description of the $$$i$$$-th constraint.\nAdditional constraints on the input:\nThe sum of $$$n$$$ across all test cases does not exceed $$$3 \\cdot 10^5$$$;\nThe sum of $$$m$$$ across all test cases does not exceed $$$3 \\cdot 10^5$$$.",
    "outputSpecification": "Output\nFor each test case, print one integer — the number of strings that satisfy the condition. Since it may be huge, output it modulo $$$998244353$$$.",
    "note": "Note\nIn the first example from the statement, the following strings are suitable:\n1010\n,\n0101\n. For each of these strings, both $$$s[1:2]$$$, $$$s[2:3]$$$, and $$$s[3:4]$$$ are beautiful.",
    "tags": [
        "combinatorics",
        "data structures",
        "dp"
    ],
    "rating": 2100
}