{
    "contestId": 2161,
    "index": "E",
    "title": "E. Left is Always Right",
    "statement": "Consider a binary string of length $$$n$$$ and an odd number $$$k$$$. We will call the binary string\ngood\nif for each substring of length $$$k$$$, the leftmost character of the substring occurs more than the other.\nFor example, if $$$k = 3$$$,\n000101\nis a good string, because for all substrings of length 3 (\n000\n,\n001\n,\n010\n, and\n101\n) the first character of the substring occurs more than the other character. On the other hand,\n1011\nis not good, because the property is false for\n011\n.\nGiven a pattern of length $$$n$$$ consisting of characters\n0\n,\n1\nand\n?\n, find the number of ways to replace question marks with\n0\nor\n1\n, such that the resulting binary string is good. Since the answer may be large, find it modulo $$$998\\,244\\,353$$$.",
    "inputSpecification": "Input\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^3$$$). The description of the test cases follows.\nThe first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$3 \\le k \\le n \\le 10^5$$$, $$$k$$$ is odd). The second line contains $$$n$$$ characters\n0\n,\n1\nor\n?\nâ€” the pattern.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "outputSpecification": "Output\nFor each test case, print the number of ways to replace\n?\nwith\n0\nor\n1\nsuch that the resulting string is good, modulo $$$998\\,244\\,353$$$.",
    "note": "Note\nIn the first example, three valid ways to make the pattern good are\n00000\n,\n00001\n, and\n00101\n. In the second example, the only invalid way (out of 16 total ways) is\n1001001\n.",
    "tags": [
        "combinatorics",
        "implementation",
        "math"
    ],
    "rating": 2400
}